<#PSScriptInfo

.VERSION 1.0

.DATE 02-Jul-2023

.AUTHOR adrian.cojocaru

#>

<#
  .SYNOPSIS
  Template for scripts meant to run inside Azure Runbooks. 
  It uses the Verbose stream for logging and therefore it is recommended that the runbook has 'Log verbose records' switched on.

  .DESCRIPTION
  Detailed description.
  Purpose. Project. Dependencies. Limitations.

  .PARAMETER Param1
  Description for Param1

  .PARAMETER Param2
  Description for Param2

  .INPUTS
  If your script accepts pipeline input, describe it here.

  .OUTPUTS
  output generated by your script. If any.

  .EXAMPLE
  .\ScriptName.ps1
  What will this do?

#>


#Region ----------------------------------------------------- [AzureAD Variables] ----------------------------------------------
[string]$TenantId = if ($env:AZUREPS_HOST_ENVIRONMENT -or $PSPrivateMetadata.JobId) { Get-AutomationVariable -Name "TenantId" } else { $env:TenantId }
[string]$ApplicationId = if ($env:AZUREPS_HOST_ENVIRONMENT -or $PSPrivateMetadata.JobId) { Get-AutomationVariable -Name "ApplicationId" } else { $env:ApplicationId }
[string]$ApplicationSecret = if ($env:AZUREPS_HOST_ENVIRONMENT -or $PSPrivateMetadata.JobId) { Get-AutomationVariable -Name "ApplicationSecret" } else { $env:ApplicationSecret }
[string]$Thumbprint = if ($env:AZUREPS_HOST_ENVIRONMENT -or $PSPrivateMetadata.JobId) { Get-AutomationVariable -Name "Thumbprint" } else { $env:Thumbprint }
[string]$SASToken = if ($env:AZUREPS_HOST_ENVIRONMENT -or $PSPrivateMetadata.JobId) { Get-AutomationVariable -Name "SASToken" } else { $env:SASToken }
[string]$StorageAccountName = if ($env:AZUREPS_HOST_ENVIRONMENT -or $PSPrivateMetadata.JobId) { Get-AutomationVariable -Name "StorageAccountName" } else { $env:StorageAccountName }
[string]$JsonPath = if ($env:AZUREPS_HOST_ENVIRONMENT -or $PSPrivateMetadata.JobId) { 'Blob SAS URL' } else { "$PSScriptRoot\Config.json" }
#EndRegion -------------------------------------------------- [AzureAD Variables] ----------------------------------------------
#Region ----------------------------------------------------- [Script Variables] ----------------------------------------------
[version]$ScriptVersion = [version]'1.0.0'
$Global:VerbosePreference = "SilentlyContinue"
$Global:GraphTokenRefreshLimit = 24
$Global:GraphTokenRefreshCount = 0
$Global:GatewayTimeoutCountLimit = 24
$Global:GatewayTimeoutCount = 0
$Global:ExitCode = 0
[string]$TimeStamp = get-date -Format yyyyMMddTHHmmss
#EndRegion -------------------------------------------------- [Script Variables] ----------------------------------------------
#Region ----------------------------------------------------- [Classes] ----------------------------------------------
class CustomException : Exception {
    <#

    .DESCRIPTION
    Used to throw exceptions.
    .EXAMPLE
    throw [CustomException]::new( "Get-ErrorOne", "This will cause the script to end with ExitCode 101")

#>
    [string] $additionalData

    CustomException($Message, $additionalData) : base($Message) {
        $this.additionalData = $additionalData
    }
}
class CustomQueryException : Exception {
    [string] $additionalData

    CustomQueryException($Message, $additionalData) : base($Message) {
        $this.additionalData = $additionalData
    }
}
#EndRegion ----------------------------------------------------- [Classes] ----------------------------------------------
#Region -------------------------------------------------------- [Functions] ----------------------------------------------
Function Write-LogRunbook {
    <#

    .DESCRIPTION
    Write messages to a log file defined by $LogPath and also display them in the console.
    Message format: [Date & Time] [CallerInfo] :: Message Text

#>
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$Message,
        [Parameter(Mandatory = $false, Position = 1)]
        [ValidateNotNull()]
        # Optional. Specifies the name of the message writter. Function, command or custom name. Defaults to FunctioName or unknown
        [string]$Caller = 'Unknown'
    )
    Begin {
        [string]$LogDateTime = (Get-Date -Format 'MM-dd-yyyy HH\:mm\:ss.fff').ToString()
    }
    Process {
        "[$LogDateTime] [${Caller}] :: $Message" | Write-Verbose -Verbose  
    }
    End {}
}

function Write-ErrorRunbook {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $false, Position = 0)]
        [AllowEmptyCollection()]
        # Optional. The errorr collection.
        [array]$ErrorRecord
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        If (-not $ErrorRecord) {
            If ($global:Error.Count -eq 0) {
                Return
            }
            Else {
                [array]$ErrorRecord = $global:Error[0]
            }
        }
    }
    Process {
        [string]$LogDateTime = (Get-Date -Format 'MM-dd-yyyy HH\:mm\:ss.fff').ToString()
        $ErrorRecord | ForEach-Object {
            $errNumber = $ErrorRecord.count - $( $ErrorRecord.IndexOf($_))
            $ErrorText = "[$LogDateTime] [${CmdletName} Nr. $errNumber] :: $($($_.Exception).Message)`n" + `
                ">>> Line: $($($_.InvocationInfo).ScriptLineNumber) Char: $($($_.InvocationInfo).OffsetInLine) <<<`n" + `
                "$($($_.InvocationInfo).Line)" 
            $ErrorText | Write-Error
        }
    }
    End {}
}
function Get-Token {
    <#
  .DESCRIPTION
  Get Authentication token from Microsoft Graph (default) or Threat Protection.
  Authentication can be done with a Certificate  Thumbprint (default) or ApplicationId Id & ApplicationSecret.
  $Thumbprint variable needs to be initialized before calling the function
  For ApplicationId & ApplicationSecret the $ApplicationId & $ApplicationSecret variables need to be initialized before calling the function.
 .Example
   Get a token for Graph using certificate thumbprint (default behaviour)
   Get-Token
 .Example
   Get a token for Defender's ThreatProtection using certificate thumbprint
   Get-Token -ThreatProtection
 .Example
   Get a token for Defender's ThreatProtection using ApplicationId & ApplicationSecret
   For ApplicationId & ApplicationSecret the variables need to be defined before calling the function: $ApplicationId & $ApplicationSecret
   Get-Token -ThreatProtection -AppIdSecret
#>
    param (
        [Parameter(Mandatory = $false, Position = 0)]
        [switch]$ThreatProtection,
        [Parameter(Mandatory = $false, Position = 1)]
        [switch]$AppIdSecret
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
    }
    End {
        try {
            $url = if ($ThreatProtection) { 'https://api.security.microsoft.com' } else { 'https://graph.microsoft.com' }
            Write-LogRunbook "url = $url" -Caller $CmdletName
            if ($AppIdSecret) {
                $body = [Ordered] @{
                    grant_type    = 'client_credentials'
                    client_id     = $ApplicationId
                    client_secret = $ApplicationSecret  
                }
                if ($ThreatProtection) {
                    $oAuthUrl = "https://login.windows.net/$TenantId/oauth2/token"
                    $body.Add('resource', $url)
                }
                else {
                    $oAuthUrl = "https://login.microsoftonline.com/$TenantId/oauth2/v2.0/token" 
                    $body.Add('scope', $url + '/.default')
                }
                Write-LogRunbook "oAuthUrl = $oAuthUrl" -Caller $CmdletName
                [string]$Token = (Invoke-RestMethod -Method Post -Uri $oAuthUrl -Body $body -ErrorAction Stop).access_token
            }
            else {
                # certificate auth
                if (-not (Get-AzContext)) {
                    Write-LogRunbook "No AzContext. Running Connect-AzAccount" -Caller $CmdletName
                    Connect-AzAccount -CertificateThumbprint $Thumbprint -ApplicationId $ApplicationId -Tenant $TenantId -ServicePrincipal
                }
                [string]$Token = (Get-AzAccessToken -ResourceUrl $url).Token
            }
            $Token
        }
        catch {
            Write-ErrorRunbook
            throw [CustomException]::new( $CmdletName, "Error calling https://api.security.microsoft.com")
        }
    }
}
function Get-JsonContent {
    param (
        [Parameter(Mandatory = $false, Position = 0, ValueFromPipeline = $true)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [string]$JsonFilePath,
        [Parameter(Mandatory = $false, Position = 1)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message string.
        [switch]$Web
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
        $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
    }
    End {
        try {
            if ($Web) {
                Invoke-RestMethod $JsonFilePath -ErrorAction Stop
            }
            else {
                if (Test-Path $JsonPath) {
                    Get-Content $JsonPath -Raw | ConvertFrom-Json 
                }
                else { throw "File not found: $JsonPath" }
            }
        }
        catch {
            Write-ErrorRunbook
            throw [CustomException]::new( $CmdletName, "Error calling json url")
        }
    }
    
}

function Get_or_Set-GraphAPI_Stuff {
    <#
.DESCRIPTION
  Please Describe the things that the function is doing.

.PARAMETER Param1

.Example
   Get_or_Set-GraphAPI_Stuff -Param1 'wwwwwwwww'

#>
    param (
        [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $false)]
        [ValidateNotNull()]
        [AllowEmptyString()]
        # Mandatory. Specifies the message Object id of the Azure AD group.
        [string]$Param1
    )
    Begin {
        [string]${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name
    }
    Process {
        try {
            $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller $CmdletName }
            $headers = @{
                Authorization  = "Bearer $Token_Graph"
                "Content-type" = "application/json"
            }
            #$url = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId/transitiveMembers?`$filter=isof('microsoft.graph.user')"
            #$url = "https://graph.microsoft.com/v1.0/groups/$AADGroupObjectId/transitiveMembers/$MemberType`?`$select=id"
            $url = ''
            $response = Invoke-RestMethod -Headers $headers -Uri $url -Method Get -ErrorAction Stop
        }
        catch {
            switch ($_.Exception.Response.StatusCode) {
                'Unauthorized' {
                    if ($Global:GraphTokenRefreshCount -lt $Global:GraphTokenRefreshLimit) {
                        Write-LogRunbook "Token expired. Getting a new one. GraphTokenRefreshCount: '$Global:GraphTokenRefreshCount'" -Caller $CmdletName
                        $global:Token_Graph = Get-GraphToken
                        $Global:GraphTokenRefreshCount++
                        Get_or_Set-GraphAPI_Stuff @PSBoundParameters
                    }
                    else {
                        Write-ErrorRunbook
                        throw [CustomException]::new( $CmdletName, "GraphTokenRefreshLimit '$Global:GraphTokenRefreshCount' reached! ")
                    }
                }
                'NotFound' { 
                    Write-LogRunbook "AzureAD object not found." -Color DarkYellow -Caller $CmdletName
                }
                Default {
                    Write-ErrorRunbook
                    throw [CustomException]::new( $CmdletName, "$($response.StatusCode) StatusCode calling '$url'")
                }
            }
        }
    }
    End {
        # Write-Log "Ended" -Caller $CmdletName
    }
}

#EndRegion -------------------------------------------------- [Functions] ----------------------------------------------
#Region -------------------------------------------------------- [Main] ----------------------------------------------
try {
    $PSBoundParameters.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "$($_.Key) = $($_.Value)" | Write-LogRunbook -Caller 'Info-Start' }
    if ($env:AZUREPS_HOST_ENVIRONMENT -or $PSPrivateMetadata.JobId) {
        # $JsonObjects = Get-JsonContent -JsonFilePath $JsonPath -Web
    }
    else {
        $ScriptName = (Get-Item $PSCommandPath).Basename
        $LogFolder = "$PSScriptRoot\Logs-$ScriptName"
        $OutputFolder = "$PSScriptRoot\Output-$ScriptName"
        $LogPath = "$LogFolder\$ScriptName-$TimeStamp.log"
        if (-not (Test-Path $LogFolder)) { New-Item -ItemType Directory $LogFolder | Out-Null }
        if (-not (Test-Path $OutputFolder)) { New-Item -ItemType Directory $OutputFolder | Out-Null }
        # $JsonObjects = Get-JsonContent -JsonFilePath $JsonPath
    }
    "====================================================================" | Write-LogRunbook -Caller 'Info-Start'
    "======================= ScriptVersion: $Scriptversion =======================" | Write-LogRunbook -Caller 'Info-Start'

    #$Token_Graph = Get-Token
    #$Token_Graph = Get-Token -AppIdSecret
    #######################
    #######################
    #######################
    # Main code goes here
    #######################
    #######################
    #######################
    <#
    $CurrentJsonObject = 1
    $JsonObjects | ForEach-Object {
        Write-LogRunbook "--------------------------------------------------------------------------------" -Caller "JsonEntry $CurrentJsonObject"
        $DateTimeBefore = Get-Date
        $GenericList = [System.Collections.Generic.List[PSObject]]::new()
        #$TableName = $_.AzureTableName
        #$AzureADGroupId = $_.AzureADGroupId
        #$AzureADGroupName = $_.AzureADGroupName
        #Write-Output "Table '$TableName'. AzureADGroupId '$AzureADGroupId' AzureADGroupName '$AzureADGroupName'"
        #######################
        # Do stuff
        #######################
        $CurrentJsonObject++
        $ElapsedTime = New-TimeSpan -Start $DateTimeBefore -End (Get-Date)
        Write-Output "Elapsed time (seconds): $($ElapsedTime.TotalSeconds)"
    }
#>
    # throw [CustomException]::new( "Get-ErrorOne", "This will cause the script to end with ExitCode 101")
    # some more code
    # throw [CustomException]::new( "Get-ErrorTwo", "This will cause the script to end with ExitCode 102")
}
catch {
    switch ($_.Exception.Message) {
        'Get-ErrorOne' { $Global:ExitCode = 101 }
        'Get-ErrorTwo' { $Global:ExitCode = 102 }
        Default { $Global:ExitCode = 300 }
    }
    Write-ErrorRunbook
}
finally {
    if ($Global:ExitCode -ne 0) { throw $_ }
    Write-LogRunbook "Execution completed with exit code: $Global:ExitCode" -Caller 'Info-End'
}
#EndRegion ----------------------------------------------------- [Main] ----------------------------------------------